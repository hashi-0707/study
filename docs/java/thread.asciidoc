== スレッドについて
=== プロセスとスレッド
* プロセス +
 各Javaアプリケーションに対してメモリ上に割り当てられた「メモリ空間」と呼ばれる領域で動作する処理単位。

* スレッド +
プロセス上で一行ずつコードを実行する一連のプログラムの処理。

* マルチプロセス +
複数のプロセスが同時に動作すること

* マルチスレッド +
複数のスレッドが同時に実行されること +
+
メモリ空間にはプログラムを実行するための様々なデータが格納されています。プロセス間ではメモリ空間は共有されませんが、スレッド間ではメモリ空間が共有されます。つまり、 異なるスレッド間で同じデータへアクセスすることができるとのこと。 +
javaアプリケーションの場合、OS上で１つのjavaプロセスが起動し、そのプロセスの中で複数のスレッドが動作します。 +
各ユーザがアプリケーションにアクセスすると、新しいスレッドが生成され、そのスレッドが処理をしれくれる。 +

=== スレッド処理の種類
* 逐次（Sequential）
一つのプロセスで複数のスレッドを順番に処理すること

* 並列（Parallel） 
複数のプロセスで各々のスレッドを同時に処理すること

* 並行（Concurrent） 
一つのプロセスで複数のスレッドを切り替えながら動作することで、疑似的に複数のスレッドを同時に処理すること + 

並列処理と並行処理がマルチスレッドに該当し、逐次処理はシングルスレッドに該当する。 +
並行処理の場合は、複数のスレッドを切り替えながら動作しているので、あるスレッドと別のスレッドが同じデータを更新してしまう場合がある。（スレッド間はメモリを共有している。） +
以下の例がわかりやすかった。 +

以下のような図書館の貸し出し予約システムがあるとします。このとき、書籍「Java並行処理プログラミング」の現時点における予約人数は0人とします。

予約人数を取得する
取得した予約人数に1を加える
予約人数を処理2. の値で更新する
アリスとボブが同時に「Java並行処理プログラミング」を予約した場合、どうなるでしょうか。タイミングによっては、以下の順番で処理が実行されてしまうことがあります。 +

A1. アリスは予約人数を取得する（=0人） +
A2. アリスは取得した予約人数に1を加える（=1人） +
B1. ボブは予約人数を取得する（=0人） +
B2. ボブは取得した予約人数に1を加える（=1人） +
A3. アリスは予約人数を処理2. の値で更新する（=1人） +
B3. ボブは予約人数を処理2. の値で更新する（=1人） +
「誰よりも早く予約した」とお互いに信じているアリスとボブは、その翌日に図書館を訪れて喧嘩になってしまいました。 +

上記の例のように、同時にアクセスされることを想定していなかったデータに対して、実際には複数スレッドから並行でアクセスが行われてしまった場合に生じるバグのことを 「レースコンディション」 と呼びます。 またプログラムにおいてシングルスレッドで動作させる必要のある範囲を 「クリティカルセクション」 といいます。 +

一方で、複数のスレッドから同時に呼び出されても正常に動作するプログラムのことを 「スレッドセーフ」 であると表現します。

=== スレッドセーフな変数とスレッドセーフでない変数
* ローカル変数
メソッド内に記述し、各メソッド、コンストラクタの状態を定義する変数。
* インスタンス変数
メソッドの外に記述し、他のメソッド、コンストラクタからも参照できる変数。同一クラス内の任意のメソッドから参照可能。フィールドとか。
* クラス変数
インスタンス変数にstatic修飾子が付与された変数。同一クラスの複数のインスタンス間で値が共有される。 +

スレッドセーフは、ローカル変数のみ。ローカル変数はスレッド毎に固有なスタック領域に格納されるため。

image::../images/スレッド.jpg[]

これらスレッドに関する考え方は以下のサイトが参考になる。
https://qiita.com/odekekepeanuts/items/b87bff49565fc9abc91b[Javaの並行処理を理解する（入門編）]

=== Springについて
ではSpringの場合はどうなるのか。以下のサイトが参考になる。 +
DIコンテナに登録したクラスがSingletonになるため、ローカル変数をうまく活用することやScopeを変更するなどの工夫が必要。 +
https://qiita.com/NagaokaKenichi/items/34bc62e572256c5710e1[ SpringのDIはSingleton(シングルトン)]











